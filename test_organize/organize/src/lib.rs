//*测试的组织结构*/

//*__________________单元测试__________________*/

//*测试模块和#[cfg(test)]*/
//测试模块的 #[cfg(test)] 标注告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做。
//这在只希望构建库的时候可以节省编译时间，并且因为它们并没有包含测试，所以能减少编译产生的文件的大小。
//与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 #[cfg(test)] 标注。
//然而单元测试位于与源码相同的文件中，所以你需要使用 #[cfg(test)] 来指定他们不应该被包含进编译结果中。


//*测试私有函数*/
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}
//例 11-12：测试私有函数
//*____________________snip_____________________*/


//*____________________集成测试_________________*/




#[cfg(test)]        //单元测试
mod tests {

    use super::*;

//*__________________测试私有函数_______________*/
    #[test]
    fn internal() {
        let a = 3;
        let b = 2;
        let result = internal_adder(a,b);
        assert_eq!(5,result,"should {}(result) = {}(a) + {}(b)",5,a,b);
    }

//*___________________snip____________________*/


//*____________________集成测试________________*/


}
